import FileAttachment from '../models/FileAttachment.js';
import User from '../models/User.js';
import { ResourceNotFoundError, InvalidInputError, AccessDeniedError } from '../utils/errorHandler.js';
import fs from 'fs';
import path from 'path';
import mongoose from 'mongoose';
import PDFDocument from 'pdfkit';
import { createWriteStream } from 'fs';

/**
 * Generate PDF document using PDFKit
 * @param {Object} data - Data to include in PDF
 * @param {Object} options - PDF generation options
 * @returns {Promise<Object>} Generated PDF file info
 */
export const generatePDF = async (data, options = {}) => {
  const { 
    filename, 
    content, 
    title = 'Document',
    subtitle = '',
    metadata = {},
    includeHeader = true,
    includeFooter = true
  } = options;
  
  // Create PDFs directory if it doesn't exist
  const pdfsDir = path.join(process.cwd(), 'uploads', 'pdfs');
  if (!fs.existsSync(pdfsDir)) {
    fs.mkdirSync(pdfsDir, { recursive: true });
  }
  
  const pdfFileName = `${filename || 'document'}-${Date.now()}.pdf`;
  const pdfPath = path.join(pdfsDir, pdfFileName);
  
  // Create PDF document
  const doc = new PDFDocument({ 
    margin: 50, 
    size: 'A4',
    info: {
      Title: title,
      Author: metadata.author || 'Payroll System',
      Subject: metadata.subject || subtitle,
      Creator: 'Payroll System',
      CreationDate: new Date()
    }
  });
  
  // Create write stream
  const stream = createWriteStream(pdfPath);
  doc.pipe(stream);
  
  // Add header
  if (includeHeader) {
    doc.fontSize(20)
       .font('Helvetica-Bold')
       .text(title, { align: 'center' });
    
    if (subtitle) {
      doc.fontSize(12)
         .font('Helvetica')
         .text(subtitle, { align: 'center' });
    }
    
    doc.moveDown(2);
    doc.fontSize(10)
       .font('Helvetica')
       .text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
    doc.moveDown(2);
  }
  
  // Add content
  if (content) {
    if (typeof content === 'string') {
      // Simple text content
      doc.fontSize(11)
         .font('Helvetica')
         .text(content, {
           align: 'left',
           indent: 0,
           lineGap: 5
         });
    } else if (Array.isArray(content)) {
      // Array of content sections
      content.forEach((section, index) => {
        if (index > 0) doc.moveDown();
        
        if (section.title) {
          doc.fontSize(14)
             .font('Helvetica-Bold')
             .text(section.title, { underline: true });
          doc.moveDown(0.5);
        }
        
        if (section.text) {
          doc.fontSize(11)
             .font('Helvetica')
             .text(section.text);
        }
        
        if (section.table) {
          // Simple table rendering
          const { headers, rows } = section.table;
          if (headers && rows) {
            doc.moveDown(0.5);
            const startY = doc.y;
            const columnWidth = (doc.page.width - 100) / headers.length;
            
            // Table header
            doc.fontSize(10).font('Helvetica-Bold');
            let x = 50;
            headers.forEach((header, i) => {
              doc.text(header, x, startY, { width: columnWidth });
              x += columnWidth;
            });
            doc.moveDown();
            
            // Table rows
            doc.font('Helvetica');
            rows.forEach(row => {
              x = 50;
              row.forEach((cell, i) => {
                doc.text(String(cell || ''), x, doc.y, { width: columnWidth });
                x += columnWidth;
              });
              doc.moveDown();
            });
          }
        }
      });
    } else if (typeof content === 'object') {
      // Object with structured content
      Object.entries(content).forEach(([key, value]) => {
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text(`${key}:`, { continued: true });
        doc.font('Helvetica')
           .fontSize(11)
           .text(String(value || 'N/A'));
        doc.moveDown(0.5);
      });
    }
  }
  
  // Add footer
  if (includeFooter) {
    const pageCount = doc.bufferedPageRange().count;
    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i);
      doc.fontSize(8)
         .font('Helvetica')
         .text(
           `Page ${i + 1} of ${pageCount} | Generated by Payroll System`,
           50,
           doc.page.height - 30,
           { align: 'center' }
         );
    }
  }
  
  // Finalize PDF
  doc.end();
  
  // Wait for stream to finish
  return new Promise((resolve, reject) => {
    stream.on('finish', () => {
      const stats = fs.statSync(pdfPath);
      resolve({
        filePath: pdfPath,
        fileName: pdfFileName,
        fileSize: stats.size,
        url: `/api/files/uploads/pdfs/${pdfFileName}`
      });
    });
    
    stream.on('error', (error) => {
      reject(new Error(`Failed to generate PDF: ${error.message}`));
    });
  });
};

export const uploadToStorage = async (file, metadata) => {
  const {
    entityType,
    entityId,
    uploadedBy,
    description,
    tags,
    category,
    isPublic = false,
    accessRoles = [],
    accessUsers = []
  } = metadata;

  if (!file || !file.path) {
    throw new InvalidInputError('File is required');
  }

  if (!entityType || !entityId || !uploadedBy) {
    throw new InvalidInputError('Entity type, entity ID, and uploaded by are required');
  }

  const user = await User.findById(uploadedBy);
  if (!user) {
    throw new ResourceNotFoundError('User');
  }

  // Get file stats
  const stats = fs.statSync(file.path);
  const fileUrl = `/api/files/${entityType}/${path.basename(file.path)}`;

  const fileAttachment = new FileAttachment({
    fileName: file.filename,
    originalFileName: file.originalname,
    fileType: file.mimetype,
    fileSize: stats.size,
    fileUrl,
    filePath: file.path,
    storageProvider: 'local',
    entityType,
    entityId: new mongoose.Types.ObjectId(entityId),
    uploadedBy,
    uploadedByName: user.name,
    description,
    tags: Array.isArray(tags) ? tags : tags ? [tags] : [],
    category,
    isPublic,
    accessRoles: Array.isArray(accessRoles) ? accessRoles : accessRoles ? [accessRoles] : [],
    accessUsers: accessUsers.map(id => new mongoose.Types.ObjectId(id)),
    status: 'active'
  });

  await fileAttachment.save();

  return fileAttachment.toObject();
};

export const deleteFromStorage = async (fileId, userId, userRole) => {
  const fileAttachment = await FileAttachment.findById(fileId);

  if (!fileAttachment) {
    throw new ResourceNotFoundError('File');
  }

  // Check access
  if (fileAttachment.uploadedBy.toString() !== userId.toString() && 
      userRole !== 'admin' && 
      !fileAttachment.accessUsers.some(id => id.toString() === userId.toString())) {
    throw new AccessDeniedError('You do not have permission to delete this file');
  }

  // Soft delete
  fileAttachment.status = 'deleted';
  fileAttachment.deletedAt = new Date();
  await fileAttachment.save();

  // Optionally delete physical file (uncomment if needed)
  // if (fileAttachment.filePath && fs.existsSync(fileAttachment.filePath)) {
  //   fs.unlinkSync(fileAttachment.filePath);
  // }

  return { message: 'File deleted successfully' };
};

export const getFileUrl = async (fileId, userId, userRole) => {
  const fileAttachment = await FileAttachment.findById(fileId);

  if (!fileAttachment) {
    throw new ResourceNotFoundError('File');
  }

  if (fileAttachment.status === 'deleted') {
    throw new ResourceNotFoundError('File has been deleted');
  }

  // Check access
  if (!fileAttachment.isPublic) {
    const hasAccess = 
      fileAttachment.uploadedBy.toString() === userId.toString() ||
      userRole === 'admin' ||
      fileAttachment.accessRoles.includes(userRole) ||
      fileAttachment.accessUsers.some(id => id.toString() === userId.toString());

    if (!hasAccess) {
      throw new AccessDeniedError('You do not have permission to access this file');
    }
  }

  return {
    fileUrl: fileAttachment.fileUrl,
    downloadUrl: `/api/files/${fileAttachment._id}/download`,
    fileName: fileAttachment.originalFileName,
    fileType: fileAttachment.fileType,
    fileSize: fileAttachment.fileSize
  };
};

export const validateFile = (file, options = {}) => {
  const {
    allowedTypes = 'all',
    maxSize = 10 * 1024 * 1024, // 10MB default
    required = true
  } = options;

  if (required && !file) {
    throw new InvalidInputError('File is required');
  }

  if (!file) {
    return true;
  }

  // Check file size
  if (file.size > maxSize) {
    throw new InvalidInputError(`File size exceeds the limit of ${maxSize / (1024 * 1024)}MB`);
  }

  // Check file type
  const allowedMimeTypes = {
    images: ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'],
    documents: [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'text/plain',
      'text/csv'
    ],
    all: []
  };

  let validMimeTypes = [];
  if (allowedTypes === 'images') {
    validMimeTypes = allowedMimeTypes.images;
  } else if (allowedTypes === 'documents') {
    validMimeTypes = allowedMimeTypes.documents;
  } else {
    validMimeTypes = [...allowedMimeTypes.images, ...allowedMimeTypes.documents];
  }

  if (validMimeTypes.length > 0 && !validMimeTypes.includes(file.mimetype)) {
    throw new InvalidInputError(`File type ${file.mimetype} is not allowed`);
  }

  return true;
};

export const getFileMetadata = async (fileId, userId, userRole) => {
  const fileAttachment = await FileAttachment.findById(fileId)
    .populate('uploadedBy', 'name email')
    .lean();

  if (!fileAttachment) {
    throw new ResourceNotFoundError('File');
  }

  if (fileAttachment.status === 'deleted') {
    throw new ResourceNotFoundError('File has been deleted');
  }

  // Check access
  if (!fileAttachment.isPublic) {
    const hasAccess = 
      fileAttachment.uploadedBy._id.toString() === userId.toString() ||
      userRole === 'admin' ||
      fileAttachment.accessRoles.includes(userRole) ||
      fileAttachment.accessUsers.some(id => id.toString() === userId.toString());

    if (!hasAccess) {
      throw new AccessDeniedError('You do not have permission to access this file');
    }
  }

  return fileAttachment;
};

export const getFilesByEntity = async (entityType, entityId, userId, userRole) => {
  const query = {
    entityType,
    entityId: new mongoose.Types.ObjectId(entityId),
    status: 'active'
  };

  // Filter by access if not admin
  if (userRole !== 'admin') {
    query.$or = [
      { isPublic: true },
      { uploadedBy: new mongoose.Types.ObjectId(userId) },
      { accessRoles: userRole },
      { accessUsers: new mongoose.Types.ObjectId(userId) }
    ];
  }

  const files = await FileAttachment.find(query)
    .populate('uploadedBy', 'name email')
    .sort({ createdAt: -1 })
    .lean();

  return files;
};

